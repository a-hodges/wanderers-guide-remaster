import { Character } from '@typing/content';

// Legacy WG .guidechar exports are version 3
const VERSION = 'pathbuilder2e';

export default async function exportToJSON(character: Character) {
  const [build, wgData] = characterToPathbuilder2e(character);
  const exportObject = {
    version: VERSION,
    success: true,
    source: "generated by Wanderer's Guide",
    build,
    wgData,
  };

  const fileName = character.name
    .trim()
    .toLowerCase()
    .replace(/([^a-z0-9]+)/gi, '-');
  downloadObjectAsJson(exportObject, fileName);
}

function downloadObjectAsJson(object: Record<string, any>, fileName: string) {
  const dataStr = 'data:text/json;charset=utf-8,' + encodeURIComponent(JSON.stringify(object));
  const downloadAnchorNode = document.createElement('a');
  downloadAnchorNode.setAttribute('href', dataStr);
  downloadAnchorNode.setAttribute('download', fileName + '.json');
  document.body.appendChild(downloadAnchorNode); // required for firefox
  downloadAnchorNode.click();
  downloadAnchorNode.remove();
}

function characterToPathbuilder2e(character: Character) {
  const build = {
    name: character.name,
    class: character.details?.class?.name,
    dualClass: null,
    level: character.level,
    ancestry: character.details?.ancestry?.name,
    heritage: null,
    background: character.details?.background,
    alignment: character.details?.info?.alignment,
    gender: character.details?.info?.gender,
    age: character.details?.info?.age,
    deity: character.details?.info?.beliefs,
    size: null,
    sizeName: null,
    keyability: getKeyAbility(character),
    languages: [],
    rituals: [],
    resistances: [],
    attributes: {},
    abilities: {},
    proficiencies: {},
    mods: {},
    feats: [],
    specials: [],
    lores: [],
    equipmentContainers: {},
    equipment: [],
    specificProficiencies: {},
    weapons: [],
    money: character.inventory?.coins,
    armor: getArmors(character),
    spellCasters: [],
    focusPoints: 0,
    focus: {},
    formula: [],
    acTotal: {},
    pets: [],
    familiars: [],
  };
  const wgData = {
    id: character.id,
    created_at: character.created_at,
    user_id: character.user_id,
    experience: character.experience,
    hp_current: character.hp_current,
    hp_temp: character.hp_temp,
    hero_points: character.hero_points,
    stamina_current: character.stamina_current,
    resolve_current: character.resolve_current,
    notes: character.notes,
    details: character.details,
    roll_history: character.roll_history,
    custom_operations: character.custom_operations,
    meta_data: character.meta_data,
    options: character.options,
    variants: character.variants,
    content_sources: character.content_sources,
    operation_data: character.operation_data,
    companions: character.companions,
  };
  return [build, wgData];
}

function getKeyAbility(character: Character) {
  const attributes = [
    'ATTRIBUTE_STR',
    'ATTRIBUTE_DEX',
    'ATTRIBUTE_CON',
    'ATTRIBUTE_INT',
    'ATTRIBUTE_WIS',
    'ATTRIBUTE_CHA',
  ];
  const classOps = character.details?.class?.operations ?? [];
  if (classOps.length === 0) {
    return undefined;
  }
  let choiceOp = null;
  for (const op of classOps) {
    if (op.type === 'adjValue' && op.data.variable in attributes) {
      return op.data.variable.split('_')[1].toLowerCase();
    } else if (op.type === 'select' && op.data.title === 'Select an Attribute') {
      choiceOp = op;
      break;
    }
  }
  if (choiceOp === null) {
    return undefined;
  }
  const choices = character.operation_data?.selections;
  const choiceList = choiceOp.data.optionsPredefined;
  if (choices === undefined || choiceList === undefined) {
    return undefined;
  }
  const choice = choices[`class_${choiceOp.id}`];
  if (choice === undefined) {
    return undefined;
  }
  for (const item of choiceList) {
    if (item.type === 'CUSTOM' && item.id === choice) {
      const ops = item.operations;
      if (ops === undefined) {
        return undefined;
      }
      for (const op of ops) {
        if (op.type === 'adjValue') {
          return op.data.variable.split('_')[1].toLowerCase();
        }
      }
    }
  }
}

function getArmors(character: Character) {
  const armors: Record<string, any>[] = [];
  if (character.inventory === undefined) {
    return armors;
  }
  for (const item of character.inventory.items) {
    if (item.item.meta_data !== undefined && item.item.group in ['ARMOR', 'SHIELD']) {
      armors.push({
        name: item.item.name,
        qty: item.item.meta_data.quantity,
        prof: null,
        pot: item.item.meta_data.runes?.potency,
        res: item.item.meta_data.runes?.striking, // not sure about this one chief
        mat: item.item.meta_data.material,
        display: item.item.name,
        worn: item.is_equipped,
        runes: item.item.meta_data.runes?.property,
      });
    }
  }
  return armors;
}
